# Git команды

Git не сможет сохранить файл без обычного сохранения файла. Нужно или всё время нажимать ctrl+C или поставить автосохранение (сохраняет каждые 2 сек.) 

Если в названиях после команды есть пробелы, то названия нужно писать в кавычках. Для перестраховки можно всегда названия писать в кавычках.
 
> *git init* - создаёт новый локальный репозиторий 
 
> *git status* - получить информацию от git o его текущем состоянии (отображает список изменённых, добавленных и удалённых файлов)

 Git status писать перед git commit для проверки о сохранении изменений. Если git status написать после git commit, то выйдейт информация,что нет изменений файлов в рабочей директории или они уже были добавлены в индекс и зафиксированы в предыдущих коммитах.

**"Working tree clean" указывает на то, что в рабочей директории нет незафиксированных изменений и рабочее дерево чистое.  
Это сообщение может появиться после выполнения команды "git status", если не внесено в проект никаких изменений после предыдущего коммита.**
 
> git config <ключ> <параметр> <значение>
 
> Ключи 
 
>--global - изменение настроек на уровне пользователя. Без указания данного ключа настройки будут изменены только на уровне текущего репозитория.
 
>--system - изменение настроек на уровне системы, т.е. сразу для всех ползователей
 
> Параметры, флаги
 
> *git config --global user.name "ваше_имя"* - установка имени пользователя
 
> *git config --global user.email "ваша_почта@gmail.com"*

> *git config --global user.name* и *git config --global user.email* писать без имени и почты для проверки имени и почты
 
> *git add "имя файла"* - добавить файл или файлы к следующему коммиту (добавляет указанные файлы в индекс)

> *git add .* - (с точкой) используется для добавления измененных файлов в индекс Git. Знак точки означает, что вы хотите добавить все измененные файлы в текущей директории и поддиректориях.
После выполнения команды "git add ." файлы становятся готовыми к коммиту, то есть они добавляются на "стейдж". Затем вы можете создать коммит, включающий все добавленные файлы, с помощью команды "git commit".  
Например, если у вас есть измененный файл "file1.txt" и новый файл "file2.txt", выполнение команды "git add ." добавит оба файла в индекс Git, и если вы затем создадите коммит, оба файла будут включены в этот коммит.
 
> *git commit -m "message"* - создание коммита (фиксирует добавленные в индекс изменения)

> *git commit -am "message"* - сохранение уже добавленого рание файла в отслеживание и создание коммита. Заменяет команду add; типа два в одном add+commit

> *git commit --amend -m* - изменить последний коммит
 
> *git rebase -i* - используя эту команду, можно объединить свои коммиты в один, если некоторые изменения будут отображаться в истории после команды git log несколько раз. Это происходит, если делать изменения в одной и той же ветке и зафиксировать их несколькими коммитами, то при просмотре истории командой git log каждый коммит будет отображаться отдельно. 
 
> *git log* - вывод на экран истории всех коммитов с их хеш-кодами

> *git log --oneline* - коротенький журнал
 
> *git checkout* - переход от одного коммита к другому
 
> *git checkout master* - вернуться к актуальному состоянию и продолжить работу
 
> *git diff* - увидеть разницу между текущим файлом и закоммиченным файлом

> *git stash* - занести изменения в отдельное хранилище

> *git stash apply* - вернуть изменения обратно в рабочую дирректорию

> *git branch* - вывод списка всех имеющихся веток

> *git branch <имя ветки>* - создания новой ветки в Git

Эта команда создаст новую ветку, но я не буду находиться в этой ветке.

> *git checkout <имя ветки>* - переключиться на новую/нужную ветку

> *git checkout -b <имя ветки>* - создание ветки и переход к ней

> *git branch -d <имя ветки>* - удалить ветку 

> *git merge <имя ветки>* - слить указанную в команде ветку с веткой, в которой я нахожусь на момент слияния

Конфликт при merge возникает, когда в разных ветках одна и та же строка написана по-разному

> *git merge --abort* - отменить слияние, которое прошло с конфликтом

> *git branch -d <имя ветки>* - удалить уже слитую ветку

> *git log --graph* - увидеть log коммитов с визуализацией веток между ними (вывод на экран истории всех коммитов с их хеш-кодами в древовидной форме)
 
![Иллюстрация к проекту](https://thumb.tildacdn.com/tild3063-3065-4466-a137-663362623733/-/resize/768x/-/format/webp/Git_config.png)
 
# Синтаксис языка Markdown
 
> "#" - знак выделяющий заголовок. После знака ставится пробел. Количество символов "#" задаёт уровень заголовка. Поддерживается 6 уровней. Чем больше знаков, тем мельче текст.
 
> "=" или "-" - подчёркиванием этими символами (не менее 3 подряд) выделяют заголовки первого ("=") и второго ("-") уровней.
 
===Например
 
> "**" или "__"- двойные знаки перед и после текста без пробела между собой и текстом  **делают начертание полужирным** или __полужирным__
 
> "*" или "_" - одинарный знак перед и после текста без пробела с текстом *делает начертание курсивным* или _курсивным_.
 
> "***" - тройной знак звёздочка без пробела с текстом делает ***полужирное курсивное начертание***.
 
> "~~" - двойной знак без пробела с текстом ~~зачёркивает текст~~.
 
> "*" в начале строки с пробелом перед текстом - ненумерованные списки. Вместо номера точка.
* Например
 
> 1, 2, 3 - нумерованные списки.
 
1 Например
 
2 Например
 
3 Напримпер
 
> git remote add origin https://github.com/arkadievna/+название нового удалённого репозитория
 
> git remote show origin
 
 
